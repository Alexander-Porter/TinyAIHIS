TinyHIS 医院信息系统设计说明书
1. 引言 (Introduction)
1.1 项目背景
TinyHIS 旨在为中小型医疗机构提供一套轻量级、智能化、全流程的信息管理系统。系统采用 B/S 架构，覆盖患者就诊、医生工作站、医技协同及行政管理等核心业务场景，并引入 AI+RAG（检索增强生成）技术辅助分诊，提升服务效率。
1.2 技术选型 (Tech Stack)
后端核心: Java 17+, Spring Boot 3.x
持久层: MyBatis-Plus, MySQL 8.0
缓存与消息: Redis (用于会话管理、队列缓冲)
实时通信: WebSocket (Netty 或 Spring WebSocket，用于叫号屏幕)
文档处理: EasyExcel (处理 xlsx 导入导出)
前端架构: Vue 3 + TypeScript + Element Plus / Vant (移动端)
AI/RAG支持: Spring AI，配合向量数据库 (如 Milvus 或 Pgvector)，对接 LLM API。
地图服务: 接入浏览器定位API (用于地理围栏签到)。
2. 需求分析 (Requirement Analysis)
2.1 角色与功能矩阵
角色
核心功能模块
业务描述
患者 (移动端)
注册/登录
实名制认证。


AI 智能分诊
点击人体图部位 -> RAG 检索 -> 推荐挂号科室。


预约/挂号
选择科室/医生/日期进行预约或当日挂号。


签到
基于 GPS 定位，到达医院范围 500m 内可点击签到入队。


诊疗记录
查看历史病历、处方、检查报告。


在线缴费
支付挂号费、药费、检查费。
医生 (PC端)
工作台
查看候诊队列、呼叫下一位（触发屏幕）。


电子病历 (EMR)
书写主诉、现病史，支持套用模板。


开立医嘱
开具处方（药单）、检查单（检验单）。
科室主任 (PC端)
模板管理
增删改查本科室的病历模板、处方套餐（公有模板）。
检验科 (PC端)
检验工作台
扫码读取检查单，录入结果（支持图文上传、表格录入）。
药房 (PC端)
发药系统
查看已缴费药单，扣减库存，确认发药。


库存管理
药品入库、盘点、预警。
管理员 (PC端)
基础数据
科室、药品字典、流水审计。


用户管理
管理医生、主任、通用账号（检验/药房）。


排班管理
设置医生一周排班表。
公共屏幕 (H5)
电子叫号屏
挂在科室门口，实时显示当前就诊、等待列表。

2.2 核心业务流程
就诊流程: 注册 -> AI分诊 -> 挂号(缴费) -> 到院GPS签到 -> 进入排队队列 -> 叫号 -> 医生看诊 -> 开单 -> 缴费 -> 检查/取药 -> 离院。
3. 概要设计 (High-Level Design)
3.1 系统架构图 (逻辑层)
[ 客户端层 ]
   |-- 移动端 (患者): Vue/H5响应式设计
   |-- PC端 (医护/管理): Vue3 Admin
   |-- 大屏端 (叫号): H5 WebSocket Client

       | (HTTP/REST / WebSocket)
       v
[ 网关/控制层 (Spring Boot) ]
   |-- AuthController (JWT认证)
   |-- TriageController (AI分诊)
   |-- QueueController (排队与WebSocket广播)
   |-- EMRController (病历与医嘱)
   |-- AdminController (后台管理)

       | (Service Layer)
       v
[ 业务逻辑层 ]
   |-- RAG Engine (向量检索 + Prompt工程)
   |-- Drools/Logic (排班校验、库存扣减)
   |-- GeoUtil (经纬度计算)

       | (ORM)
       v
[ 数据存储层 ]
   |-- MySQL (核心业务数据)
   |-- Redis (排队队列、Token)
   |-- MinIO/LocalDisk (检查报告图片/PDF)
   |-- Vector DB (医疗知识库，用于AI分诊)


4. 详细设计 (Detailed Design)
4.1 数据库设计 (Database Schema)
仅列出核心表结构设计。
4.1.1 用户与基础数据
sys_user: user_id, username, password, real_name, role (DOCTOR, CHIEF, ADMIN, PHARMACY, LAB), dept_id
patient_info: patient_id, name, id_card, phone, gender, age
department: dept_id, dept_name, location (用于导航), screen_id (关联的大屏设备ID)
drug_dict: drug_id, name, spec (规格), price, stock_quantity, unit
4.1.2 挂号与排队
schedule: schedule_id, doctor_id, date, shift_type (AM/PM), max_quota, current_count
registration: reg_id, patient_id, doctor_id, schedule_id, status (0:待支付, 1:已支付/待签到, 2:已签到/候诊, 3:就诊中, 4:已完成, 5:取消), queue_number (排队号), create_time
4.1.3 电子病历与医嘱
medical_record: record_id, reg_id, patient_id, doctor_id, symptom (主诉), diagnosis (诊断), content (病史详情), create_time
prescription: pres_id, record_id, drug_id, quantity, usage_instruction, status (0:待缴费, 1:已缴费, 2:已发药)
lab_order: order_id, record_id, item_name, price, status (0:待缴费, 1:已缴费/待检, 2:已完成), result_text, result_images (JSON数组存储URL)
4.1.4 模板管理
emr_template: tpl_id, dept_id (为空则为全院通用), creator_id (主任ID), name, content (模板文本), type (病历/处方)
4.2 核心模块算法与逻辑设计
4.2.1 AI 分诊 (AI + RAG)
场景: 患者点击“腹部”，描述“隐痛三天”。
流程:
前端: 收集部位 tag 和用户描述 text。
后端:
将文本转化为向量 (Embedding)。
在向量数据库中检索相似的“症状-科室”映射知识库 (Knowledge Chunk)。
构建 Prompt: 基于以下参考信息：{Context}，用户症状为：{UserQuery}，请推荐挂号科室并给出简短理由。
LLM: 返回推荐科室（如“消化内科”）。
Java代码逻辑示意:
public TriageResult aiTriage(String bodyPart, String description) {
    String query = bodyPart + " " + description;
    List<Document> similarDocs = vectorStore.similaritySearch(query);
    String prompt = promptTemplate.format(similarDocs, query);
    return llmClient.chat(prompt);
}


4.2.2 基于地理位置的签到 (Geo-Fencing)
需求: 只有患者在医院 500米范围内，才能点击“签到”进入排队队列。
算法: Haversine 公式（计算两点间球面距离）。
逻辑:
管理员预设医院经纬度 (TargetLat, TargetLon)。
前端调用 HTML5 Geolocation API 获取用户当前 (UserLat, UserLon)。
Java后端校验：
public boolean checkIn(Long regId, double userLat, double userLon) {
    double distance = GeoUtils.calculateDistance(userLat, userLon, HOSPITAL_LAT, HOSPITAL_LON);
    if (distance > 500) {
        throw new BusinessException("距离医院过远，无法签到");
    }
    // 更新状态为“候诊”，写入Redis队列
    updateStatus(regId, Status.WAITING);
    queueService.addToQueue(doctorId, regId);
    return true;
}


4.2.3 电子叫号系统 (WebSocket)
模型: 生产者-消费者模型。
生产者: 医生点击“叫号”。
消费者: 科室门口的 H5 大屏。
流程:
医生调用 /api/doctor/callNext。
后端更新当前就诊人状态，从 Redis List 中 LPOP 下一位患者。
后端通过 WebSocket 推送消息给订阅了该科室 Topic 的大屏客户端。
// WebSocket Message Payload
{
  "type": "CALLING",
  "deptId": 101,
  "content": "请 105 号 张三 到 2号诊室 就诊"
}


4.2.4 复杂数据导入导出 (Excel)
技术: Alibaba EasyExcel。
场景: 药房批量导入药品库存，或管理员导出月度流水。
设计: 使用注解 @ExcelProperty 标记实体类，通过 Listener 模式流式读取，避免 OOM (内存溢出)。
4.3 界面设计 (UI UX)
4.3.1 患者端 (Mobile)
首页: 顶部 Banner，中部金刚区（预约挂号、AI分诊、门诊缴费、报告查询），底部导航栏。
AI分诊页: 人体 SVG 交互图，点击高亮部位，底部弹出输入框。
挂号页: 科室列表 -> 医生排班日历 -> 确认支付。
4.3.2 医生工作站 (PC Web)
布局: 左右分栏。
左侧: 候诊列表（显示排队号、姓名、状态）。顶部有“叫号”、“重呼”、“过号”按钮。
右侧: 选项卡式布局（病历录入、开处方、开检查）。
辅助功能: 右侧边栏可折叠，显示“病历模板”和“套餐”，支持拖拽或双击上屏。
4.3.3 检验科工作站
待检列表: 扫描患者二维码或输入就诊卡号查询待检项目。
结果录入:
文本: 富文本编辑器。
表格: 动态 Grid，适用于血常规等指标录入。
图片: 拖拽上传区域（X光/CT图）。
4.3.4 科室大屏
全屏展示: 深色背景。
左侧 (70%): 正在呼叫（特大字号：105号 张三 -> 1诊室）。
右侧 (30%): 等待列表（滚动展示）。
底部: 跑马灯公告。
5. 开发实施计划 (Implementation)
Phase 1: 基础框架与数据: 完成 Spring Boot 搭建，MySQL 建表，Redis 配置，完成用户体系和排班管理。
Phase 2: 核心就诊链路: 挂号 -> 签到 -> 医生叫号 -> 写病历。此阶段暂不包含 AI 和 支付对接。
Phase 3: 医技与药房: 实现检验科上传结果、药房库存扣减。
Phase 4: 智能化与报表: 集成 AI 分诊接口，开发 WebSocket 大屏，实现 Excel 导入导出。
Phase 5: 部署与测试: 使用 Docker Compose 部署后端、Redis、MySQL 和 Nginx。
6. 接口定义示例 (API Design Example)
API: 获取排班列表
GET /api/schedule/list
Params: deptId, startDate, endDate
Response:
{
  "code": 200,
  "data": [
    {
      "date": "2023-11-01",
      "shift": "AM",
      "doctorName": "王专家",
      "quotaLeft": 5
    }
  ]
}


API: 提交病历
POST /api/emr/save
Body:
{
  "regId": 10023,
  "symptom": "头痛发热",
  "diagnosis": "上呼吸道感染",
  "prescription": [
    {"drugId": 501, "count": 2}
  ]
}


